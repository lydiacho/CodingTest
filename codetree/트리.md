## 트리

- 용어

  - 노드 (정점)
  - 간선 (에지)
  - 루트 노드 : 트리의 맨 꼭대기
  - 부모, 자식 : 위아래 두 노드의 관계
  - 차수 : 특정 노드의 자식 수
  - 깊이 : 특정 노드가 루트 노드와 얼마나 떨어져 있는지
  - 높이 : 깊이가 가장 깊은 노드의 깊이 + 1
  - 리프 노드 : 자식을 갖지 않는 노드

- 정의 : 노드끼리 전부 연결되어 있으면서, 사이클이 존재하지 않는 그래프
  - 부모 자식 관계가 없는경우 Unrooted tree
  - Unrooted tree의 차수는 연결된 간선의 개수 (차수 1인 노드가 리프 노드, 루트 노드는 정하기 나름)

### 테스트 - 트리 상식

- 루트가 정해져있는 트리의 경우, 루트는 단 하나만 존재
- 트리에서의 루트는 정해져있지 않고, 상황별로 어떤 노드가 루트가 될지 달라질 수도 있음
- 한 노드가 가질 수 있는 자식 노드의 개수는 제한이 없지만, 자식노드의 부모 노드는 단 하나만 존재
- 리프 노드는 자식이 없는 노드
- 노드가 하나만 있어도 모든 노드가 이어져있고 사이클이 존재하지 않기 때문에 트리임.

---

## 이진트리 개념

- 이진트리 : 트리에서 자식의 수를 최대 2개로 제한
- 배열로 구현 가능
- 0인덱스 비우고, 1부터 왼쪽 자식은 `i*2`, 오른쪽 자식은 `i*2+1`

### 테스트 - 모양 예측하기

```
- 1 2 3 4 0 0 5
```

---

## 이진트리 탐색

- 전위 탐색 : 부모 -> 왼쪽자식 -> 오른쪽 자식 (VLR)
- 중위 탐색 : 왼쪽자식 -> 부모 -> 오른쪽자식 (LVR)
- 후위 탐색 : 왼쪽자식 -> 오른쪽자식 -> 부모 (LRV)

```js
function preorder(n)
  if n == null
    return
  visit(n)
  preorder(n.left)
  preorder(n.right)

function inorder(n)
  if n == null
    return
  inorder(n.left)
  visit(n)
  inorder(n.right)

function postorder(n)
  if n == null
    return
  postorder(n.left)
  postorder(n.right)
  visit(n)

```

### 테스트 - 전위 탐색

(VLR)

```
1 2 4 6 7 3 5 8
```

---

https://www.codetree.ai/missions/6/problems/find-spy/introduction

## 이진 탐색 트리

- Binary Search Tree
- 이진트리에서 특성 하나 추가
- 부모의 왼쪽 방향에 있는 노드들은 전부 부모 보다 값이 작아야 하고, 부모의 우측 방향에 있는 노드들은 전부 부모 보다 값이 커야함
- **이진트리는 이진탐색트리와 다른 친구임에 유의!**

**▶️ 이진탐색트리의 탐색**

- 루트 노드에서 시작해 목표값과 일치할 때까지 이동
- 현재값이 타겟보다 크면 왼쪽으로, 작으면 오른쪽으로 이동

```js
function bst.search(x)
    set node = bst.root                     // root에서 시작합니다.
    while node != null and node.value != x  // node에 들어있는 값이 x가 되기 전까지 계속 반복합니다.
        if node.value > x                   // 노드에 있는 값이 x보다 크다면
            node = node.left                // 왼쪽 자식으로 내려와 탐색을 진행합니다.
        else                                // 노드에 있는 값이 x보다 작다면
            node = node.right               // 오른쪽 자식으로 내려와 탐색을 진행합니다.

    return node                             // 최종 위치를 반환합니다.

```

**▶️ 이진탐색트리의 삽입**

- 탐색 과정과 똑같이 이동하지만, **null에 도달할 때까지 계속 이동** & null 찾으면 해당 위치에 요소 추가
- 부모 노드에 대한 정보도 계속 유지해야 함
- 부모 노드를 기준으로 새로운 자식을 추가하는 방법
  - 트리에 노드가 없을 때 = parent가 null : root를 node(x)로 설정
  - parent가 x보다 클 때 : 왼쪽 자식에 node(x)삽입
  - parent가 x보다 작을 때 : 오른쪽 자식에 node(x)삽입

```js
function bst.insert(x)
    set node = bst.root          // root에서 시작합니다.
    set parent = bst.root        // parent도 root로 설정하고 시작합니다.

    while node != null           // node가 null이 되기 전까지 반복합니다.
        parent = node            // parent는 항상 node가 움직이기 직전의 위치로 갱신해줍니다.
        if node.value > x        // node에 적혀있는 값이 x보다 크다면
            node = node.left     // 왼쪽 자식으로 이동해야 합니다.
        else                     // node에 적혀있는 값이 x보다 작다면
            node = node.right    // 오른쪽 자식으로 이동해야 합니다.

    if parent == null            // Case 1. 비어있는 tree라면
        bst.root = node(x)       // root를 node(x)로 설정해줍니다.
    else if parent.value > x     // Case 2. parent에 적혀있는 값이 추가하려는 값 x보다 크다면
        parent.left = node(x)    // parent의 왼쪽에 node(x)를 넣어줍니다.
    else                         // Case 3. parent에 적혀있는 값이 추가하려는 값 x보다 작다면
        parent.right = node(x)   // parent의 오른쪽에 node(x)를 넣어줍니다.
```

**▶️ 이진탐색트리의 삭제**

- 먼저 삭제할 값 x를 찾음
- case에 따라 세가지 중 하나 실행
  - x의 왼쪽 노드가 비어있으면, 오른쪽 노드를 위로 올려줌
  - 오른쪽 노드가 비어있으면, 왼쪽 노드를 위로 올려줌
  - 양쪽 노드가 전부 있다면, successor를 찾아야 함
    - successor : 현재 노드보다 더 크면서 가장 작은 값을 갖는 노드
    - **오른쪽 자식**을 시작으로 최대한 **왼쪽으로 내려가서** 찾을 수 있음
- successor 값을 node로 옮겨주고, successor의 오른쪽 자식을 위로 올려주기 (successor가 node의 오른쪽 자식일 경우 그냥 오른쪽 노드 그대로 위로 올려주기)

```js
function bst.search(x)
    set node = bst.root
    while node != null and node.value != x
        if node.value > x
            node = node.left
        else
            node = node.right

    return node

function bst.minimum(node)                  // node 하위 트리에서 최솟값을 구합니다.
    while node.left != null                 // node의 left가 null이 아니면 계속 내려갑니다.
        node = node.left
    return node                             // 최종 node의 위치를 반환합니다.

function bst.delete(x)                      // x를 찾아 삭제하는 함수입니다.
    set node = bst.search(x)                // x 값을 찾습니다.

    if node.left == null                    // Case 1. node의 왼쪽 자식이 비어있다면
        move(node.right, node)              // 오른쪽 자식을 위로 올려줍니다.
    else if node.right == null              // Case 2. node의 오른쪽 자식이 비어있다면
        move(node.left, node)               // 왼쪽 자식을 위로 올려줍니다.
    else                                    // Case 3. 왼쪽 오른쪽 자식이 모두 채워져있다면
        set succ = bst.minimum(node.right)  // 해당 노드의 successor를 구합니다.
                                            // 이는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가는 것을
                                            // 반복하면 가능합니다.
        if succ == node.right               // 만약 successor가 현재 노드의 오른쪽 자식이라면
            move(node.right, node)          // 오른쪽 자식을 위로 올려줍니다.
        else                                // 그렇지 않은 일반적인 경우라면
            node.value = succ.value         // node의 값을 successor의 값으로 대체시켜준 뒤,
            move(succ.right, succ)          // successor의 오른쪽 자식을 위로 끌어올려줍니다.

```

**▶️ 균형잡힌 이진 탐색 트리**

- 이진탐색트리가 일방향으로 형성될 경우 삽입/삭제/탐색 모두 O(N)이다.
- O(logN)인 균형잡힌 이진탐색트리를 만들기 위해 Red Black Tree, AVL Tree 같은 규칙이 있다.
  - 노드를 회전시키면서 왼쪽과 오른쪽의 높이 차를 최소화하는 방법들

### 테스트 - 이진 탐색 트리에서 값 넣기

- 이진탐색트리는 어떤 순서로 값을 넣냐에 따라 트리 모양이 달라진다.

---

## Heap

### 테스트 - 힙에서의 삽입

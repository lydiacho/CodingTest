## 동적계획법

- 동적 계획법 : 큰 문제를 해결하기 위해 작은 문제를 먼저 해결하고, 그 결과를 이용해 비교적 간단하게 해결하는 기법
- **점화식**을 기반으로 구현한다.
- `F(n) = F(n-1) * n` 이런 점화식을 구현할 수 있는 방법은 2가지

1. **for loop**

```js
F[1] = 1
for i = 2 ... i <= n
    F[i] = F[i - 1] * i

print(F[n])
```

2. **재귀 함수**
   재귀 함수는 **종료조건**으로 초기 조건을 넣어주고, 그렇지 않은 경우 점화식을 적어주면 된다.

```js
function f(n)
    if n == 1
        return 1
    else
        return f(n - 1) * n

print(f(n))
```

---

## Memoization

재귀함수는 아래와 같은 경우 한계가 있다.

```js
function fibbo(n)
    if n <= 2
        return 1
    else
        return fibbo(n - 1) + fibbo(n - 2)

fibbo(50)
```

중복으로 계산될 때가 많기 때문이다.

따라서 반복 계산을 제거하기 위해 memoization을 할 수 있다.

- memoization : 값을 기록하고, 기록한 값을 참조하는 것
- 시간복잡도 O(2^n)를 O(n)으로 개선시켜주는 방식
- 구현 방법
  - `memo`라는 배열을 이용하자.
  - 초기값은 **답이 될 수 없는 값** (피보나치에서는 -1)
  - `memo`에서 해당 값이 -1이면, 계산 후 결과값 저장
  - `memo`에 해당 값이 -1이 아니면, 계산하지 않고 저장되어있던 값 사용

memoization 활용해서 피보나치 구하는 예제

```js
function fibbo(n)
    if memo[n] != -1           // 이미 n번째 값을 구해본 적이 있다면
        return memo[n]         // memo에 적혀있는 값을 반환해줍니다.
    if n <= 2                  // n이 2이하인 경우에는 종료 조건이므로
        memo[n] = 1            // 해당하는 숫자를 memo에 넣어줍니다.
    else                       // 종료조건이 아닌 경우에는
        memo[n] = fibbo(n - 1) + fibbo(n - 2)   // 점화식을 이용하여 답을 구한 뒤
                                                // 해당 값을 memo에 저장해줍니다.
    return memo[n]             // memo 값을 반환합니다.

```

- 유형

  - 파도반 수열 : P(N) = P(N-2) + P(N-3) (1,1,1로 시작)

  ```js
  memo = [-1, -1, -1, ...]

  function padovan(n)
      if memo[n] != -1
          return memo[n]
      if n <= 3
          memo[n] = 1
      else
          memo[n] = padovan(n - 2) + padovan(n - 3)
      return memo[n]
  ```

---

## Tabulation

재귀함수 풀이법 외에, for문을 통해 **순서대로 배열**의 값을 채워나가는 방식을 **Tabulation**이라고 한다.

```js
set dp = [0, 0, 0, ...]

dp[1] = 1
dp[2] = 1

for i = 3 ... i <= n:
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
```

- Memoization : Top-Down 방식
- Tabulation : Bottom-Up 방식
- 시간복잡도는 비슷하나, Tabulation이 조금 더 빠름

파도반을 Tabulation으로 구현한 예제

```js
function solution(n)
    dp = [0, 0, 0, ...]
    dp[1] = 1
    dp[2] = 1
    dp[3] = 1

    for i = 4 ... i <= n
        dp[i] = dp[i - 3] + dp[i - 2]

    return dp[n]
```

---

## subproblem을 그대로 합치면 되는 DP

- 타일 채우기
  - 2xi 짜리 벽을 2x1, 1x2 타일로 채우는 경우의 수
  - dp[i] = dp[i-1] + dp[i-2] (1,1로 시작)
- 노드 n개로 만들 수 있는 서로다른 BST 개수
  - (루트보다 작은 수들로 만들 수 있는 BST 개수) \* (루트보다 큰 수들로 만들 수 있는 BST 개수)
  - dp[n] = (dp[i]\*dp[n-i-1])의 i=0...n-1 합계
  - dp[2] = dp[0] _ dp[1] + dp[1] _ dp[0] = 2
  - dp[3] = dp[0] _ dp[2] + dp[1] _ dp[1] + dp[2] \* dp[0] = 2 + 1 + 2 = 5
  - dp[4] = dp[0]dp[3] + dp[1]dp[2] + dp[2]dp[1] + dp[3]dp[0] = 5 + 2 + 2 + 5 = 14
  - dp[5] = [0][4] + [1][3] + [2][2] + [3][1] + [4][0] = 14 + 5 + 4 + 5 + 14 = 42
  - dp[6] = ([0][5] + [1][4] + [2][3])*2 = (42+14+10)*2 = 132

---

## 격자 안에서 한 칸씩 전진하는 DP

- 최상단에서 최하단으로 이동했을 때 얻는 최대 합
- (r,c)에서 이동은 (r+1,c) 혹은 (r+1, c+1)로만 이동 가능
- dp[i][j] = max(dp[i-1][j] + a[i][j], dp[i-1][j-1] + a[i][j])

---

## 조건에 맞게 선택적으로 전진하는 DP

- LIS(가장 긴 증가 부분 수열) 길이 구하기
- dp[i] : 마지막으로 고른 원소의 위치가 i인 부분 수열 중 최장 증가 부분 수열의 길이
- dp[i] = max(dp[j]) + 1

  - j : 1 ~ i-1
  - j : a[j] < a[i] 이어야 함

- 테스트 : 가장 긴 감소하는 부분수열
  ```
  60 65 50 70 63 55 45 51 45 48 54 70 61
  1  1  2  1  2  3  4  4  5  5  4  2  3
  ```
  => 5

---

## 아이템을 적절히 고르는 문제

- **주어진 동전으로 특정 금액 채울 때 필요한 최소 동전의 수**
- dp[i] : 지금까지 선택한 동전의 합 i라 했을 때, 필요한 최소 동전 개수
- 마지막 동전으로 coin[j] 골랐을 때, 이전 동전들로 만들어야 했던 합은 i-coin[j]
  - dp[i] = min( dp[i-coin[j]] + 1 )
    - j는 1~n, 단 i >= coin[j]
  - dp[4] = (coin[j]가 1or4) = min (dp[3]+1, dp[0]+1) = 1
  - dp[5] = (coin[j]가 1or4or5) = min(dp[4]+1, dp[1]+1, dp[0]+1) = min(2, 2, 1) = 1
  - dp[6] = (coin[j]가 1or4or5) = min(dp[5]+1, dp[2]+1, dp[1]+1) = min(3, 3, 2) = 2
  - dp[7] = (coin[j]가 1or4or5) = min(dp[6]+1, dp[3]+1, dp[2]+1) = min(3, 4, 3) = 3
  - dp[8] = (coin[j]가 1or4or5) = min(dp[7]+1, dp[4]+1, dp[3]+1) = min(4, 2, 4) = 2
- 기본문제-은행

  - dp[11] = (coin이 1,4,5,9) = min(dp[10]+1, dp[7]+1, dp[6]+1, dp[2]+1) = min(3, 4, 3, 3) = 3
  - dp[16] = min(dp[15]+1, dp[12]+1, dp[11]+1, dp[7]+1) = min(4, 4, 4, 4) = 4
  - dp[17] = min(dp[16]+1, dp[13]+1, dp[12]+1, dp[8]+1) = min(5, 3, 4, 3) = 3
  - dp[21] = min(dp[20]+1, dp[17]+1, dp[16]+1, dp[12]+1) = min(5, 4, 5, 4) = 4;

- **도둑 가방과 보석 훔치기**
- DP table : (1~보석종류)행 X (0~가방크기)열
- dp[i][j] : i번째 보석까지 고려했고, 주워담은 보석 무게의 합이 j일 때, 보석 가치의 최대 합
- i번째 보석을 넣었는지 / 안넣었는지 여부로 나눠서 점화식 세우기

  - i를 넣은 경우 : dp[i-1]j-weight[i]] + value[i] (단, j >= weight[i])
  - i를 넣지 않은 경우 : dp[i-1][j]
    이 두가지 중 **더 큰 가치를 선택**
  - 첫번째 보석을 넣냐/마냐 부터 시작해서 테이블을 채워나가기

- 예제 문제
  - dp[2][3] = max(dp[1][2]+1, dp[1][3]) = 4
  - dp[3][5] = max(dp[2][1]+2, dp[2][5]) = 3
  - dp[3][8] = max(dp[2][4]+2, dp[2][8]) = 7
  - dp[5][1] = dp[4][1] = 1
  - dp[5][7] = max(dp[4][5]+3, dp[3][7]) = 9

---

## String Matching

- LCS : Longest Common Subsequence. 최장 공통 부분 수열
  - 예 : ABABA, BAAB -> LCS는 BAB, LCS의 길이는 3
- dp[i][j] : 문자열 A의 i번째까지와 문자열 B의 j번째까지를 활용하여 만들 수 있는 LCS의 길이
- 점화식 세우기 기준 : A의 i번째 글자와 B의 j번째 글자가 다른경우 / 같은 경우 -> 2가지로 나뉨
  🚀 **다를 경우**
  DP[i][j] = max(DP[i-1][j], DP[i][j-1])

🚀 **같을 경우**
i번째 글자와 j번째 글자를 매칭하는 것이 **항상** 좋음
DP[i][j] = DP[i-1][j-1]+1

- DP table 채우기
  - dp[1][1] : 두 첫 글자가 같으면 1, 다르면 0
  - 첫번째 행, 열 모두 채우기
  - dp[2][2]부터 점화식에 따라 채워주기

### 테스트 - Edit Distance

- 편집 거리 : 문자열 A를 문자열 B로 바꾸기 위해 필요한 최소 연산 횟수
  - 연산 : 한 문자를 특정 위치에 삽입 / 특정 문자 삭제
    -> sol :

1. LCS 구하고
2. 문자열 A 길이 - LCS : 삭제해야 하는 횟수
3. 문자열 B 길이 - LCS : 삽입해야 하는 횟수

```
  A B B B D A A A
B 0 1 1 1 1 1 1 1
A 1 1 1 1 1 2 2 2
D 1 1 1 1 2 2 2 2
A 1 1 1 1 2 3 3 3
B 1 2 2 2 2 3 3 3
B 1 2 3 3 3 3 3 3
D 1 2 3 3 4 4 4 4
B 1 2 3 4 4 4 4 4
A 1 2 3 4 4 5 5 5
```

-> LCS = 5
-> 편집거리 = 3 + 4 = **7**

---

## Greedy Algorithm

- **0/1 Knapsack 문제** : 보석을 쪼개담을 수 없고 담거나/담지 않는 선택지만 있는 문제 => **동적계획법으로 해결**
- **Fractional Knapsack 문제** : 보석을 쪼개담을 수 있는 문제 => **동적계획법 없이 해결 가능**
  - 항상 무게 대비 가격이 높은 보석을 담으면 됨 (가격/무게)
- 그리디 알고리즘 : 현재 상황에서 최선이다 싶은 것을 계속 반복하는 알고리즘 (Fractional Knapsack 문제에서는 최적의 답을 가져와줌)

### 테스트 - 쪼개어 배낭 채우기2

무게 대비 가격

- 1번 : 3/2 = 16/12
- 2번 : 5/6 = 10/12
- 3번 : 4/2 = 24/12
- 4번 : 2/3 = 8/12
- 5번 : 3/4 = 9/12

3번(2) -> 1번(2) -> 2번(6)쪼개기
-> `최대 가치 : 4 + 3 + 5*4/6 = 10.333`
